#include "cc__gen.hpp"

int main() {
    global_init();
    bool ok = true;
    auto L = lang::cc::init();
    ok = ok && L->test_example(Some<string>("Expr"), "x().y", -1, true);
    ok = ok && L->test_example(Some<string>("Expr"), "x.y()", -1, true);
    ok = ok && L->test_example(Some<string>("Expr"), "x.A::b", -1, true);
    ok = ok && L->test_example(Some<string>("Expr"), "A::x.b", -1, true);
    ok = ok && L->test_example(Some<string>("Module"), "struct\040A\040{\n\040\040\040\040int\040x;\n\040\040\040\040float\040y;\n};\n", -1, true);
    ok = ok && L->test_example(Some<string>("Stmt"), "{\n\040\040\040\040{\n\040\040\040\040\040\040\040\040{\n\040\040\040\040\040\040\040\040\040\040\040\040{\n\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040{\n\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040x\040+\0403;\n\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040}\n\040\040\040\040}\n}", -1, true);
    ok = ok && L->test_example(Some<string>("Module"), "inline\040void\040pr(ostream&\040os,\040const\040Buffer&\040A)\040{\n\040\040\040\040fmt(os,\040\"Buffer[{}]:\\n\",\040A.N_);\n\040\040\040\040if\040(A.N_\040<=\040256L\040+\04064L)\040{\n\040\040\040\040\040\040\040\040for\040(Int\040i\040=\0400;\040i\040_LT_\040A.N_;\040i++)\040{\n\040\040\040\040\040\040\040\040\040\040\040\040os\040<<\040byte_to_hex(A.v_[i]);\n\040\040\040\040\040\040\040\040\040\040\040\040pr_buffer_sep(os,\040i);\n\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040if\040(A.N_\040%\04064\040!=\0400)\040{\n\040\040\040\040\040\040\040\040\040\040\040\040os\040<<\040\"\\n\";\n\040\040\040\040\040\040\040\040}\n\040\040\040\040}\040else\040{\n\040\040\040\040\040\040\040\040for\040(Int\040i\040=\0400;\040i\040_LT_\040256L;\040i++)\040{\n\040\040\040\040\040\040\040\040\040\040\040\040os\040<<\040byte_to_hex(A.v_[i]);\n\040\040\040\040\040\040\040\040\040\040\040\040pr_buffer_sep(os,\040i);\n\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040os\040<<\040\"...\\n\";\n\040\040\040\040\040\040\040\040Int\040N_base\040=\040A.N_\040-\04064;\n\040\040\040\040\040\040\040\040for\040(Int\040i\040=\0400;\040i\040_LT_\04064;\040i++)\040{\n\040\040\040\040\040\040\040\040\040\040\040\040os\040<<\040byte_to_hex(A.v_[N_base\040+\040i]);\n\040\040\040\040\040\040\040\040\040\040\040\040pr_buffer_sep(os,\040i);\n\040\040\040\040\040\040\040\040}\n\040\040\040\040}\n}\n", -1, true);
    ok = ok && L->test_example(Some<string>("Module"), "template<typename\040T>\040inline\040void\040fmt_acc(ostream&\040os,\040vector<string>&\040args_acc,\040T\040t)\040{\n\040\040\040\040args_acc.push_back(pr_str(t));\n}\n", -1, true);
    ok = ok && L->test_example(Some<string>("Module"), "namespace\040BinOp\040{\n\040\040\040\040enum\040struct\040Which\040{\n\040\040\040\040\040\040\040\040ADD,\n\040\040\040\040\040\040\040\040SUB,\n\040\040\040\040\040\040\040\040MUL,\n\040\040\040\040\040\040\040\040DIV,\n\040\040\040\040};\n\n\040\040\040\040struct\040_S:\040Expr::_S\040{\n\040\040\040\040\040\040\040\040Which\040which_binop_;\n\040\040\040\040\040\040\040\040Expr_S\040lhs;\n\040\040\040\040\040\040\040\040Expr_S\040rhs;\n\040\040\040\040\040\040\040\040_S(Which\040w,\040Expr_S\040lhs,\040Expr_S\040rhs)\040:\040which_binop_(w),\040Expr::_S(Expr::Which::BinOp),\040lhs(lhs),\040rhs(rhs)\040{\n\040\040\040\040\040\040\040\040}\n\040\040\040\040};\n\n\040\040\040\040Expr::BinOp_S\040make_ADD(Expr_S\040lhs,\040Expr_S\040rhs)\040{\n\040\040\040\040\040\040\040\040return\040make_shared<Expr::BinOp::_S>(Which::ADD,\040lhs,\040rhs);\n\040\040\040\040}\n}\n", -1, true);
    ok = ok && L->test_example(Some<string>("Module"), "namespace\040Expr\040{\n\040\040\040\040enum\040struct\040Which\040{\n\040\040\040\040\040\040\040\040_UNINIT_,\n\040\040\040\040\040\040\040\040BinOp,\n\040\040\040\040\040\040\040\040Lit,\n\040\040\040\040};\n}\n\nnamespace\040Expr\040{\n\040\040\040\040struct\040_S:\040std::enable_shared_from_this<_S>\040{\n\040\040\040\040\040\040\040\040Expr::Which\040which_expr_;\n\040\040\040\040\040\040\040\040_S(Expr::Which\040w)\040:\040which_expr_(w)\040{\n\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040_S()\040=\040delete;\n\040\040\040\040\040\040\040\040virtual\040~_S()\040{\n\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040Expr::Which\040which()\040{\n\040\040\040\040\040\040\040\040\040\040\040\040return\040which_expr_;\n\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040bool\040is_BinOp()\040{\n\040\040\040\040\040\040\040\040\040\040\040\040return\040which_expr_\040==\040Expr::Which::BinOp;\n\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040bool\040is_Lit()\040{\n\040\040\040\040\040\040\040\040\040\040\040\040return\040which_expr_\040==\040Expr::Which::Lit;\n\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040Expr::BinOp_S\040as_BinOp()\040{\n\040\040\040\040\040\040\040\040\040\040\040\040AT(this->is_BinOp());\n\040\040\040\040\040\040\040\040\040\040\040\040return\040dynamic_pointer_cast<Expr::BinOp::_S>(this->shared_from_this());\n\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040Expr::Lit_S\040as_Lit()\040{\n\040\040\040\040\040\040\040\040\040\040\040\040AT(this->is_Lit());\n\040\040\040\040\040\040\040\040\040\040\040\040return\040dynamic_pointer_cast<Expr::Lit::_S>(this->shared_from_this());\n\040\040\040\040\040\040\040\040}\n\040\040\040\040};\n}\n\nnamespace\040Expr::BinOp\040{\n\040\040\040\040enum\040struct\040Which\040{\n\040\040\040\040\040\040\040\040_UNINIT_,\n\040\040\040\040\040\040\040\040Add,\n\040\040\040\040\040\040\040\040Sub,\n\040\040\040\040\040\040\040\040Mul,\n\040\040\040\040\040\040\040\040Div,\n\040\040\040\040};\n}\n\nnamespace\040Expr\040{\n\040\040\040\040Expr::BinOp_S\040make_BinOp(Expr::BinOp::Which\040w,\040Expr_S\040lhs,\040Expr_S\040rhs)\040{\n\040\040\040\040\040\040\040\040return\040make_shared<Expr::BinOp::_S>(w,\040lhs,\040rhs);\n\040\040\040\040}\n}\n\nvoid\040pr(ostream&\040os,\040FmtFlags\040flags,\040Expr::BinOp::Op\040op)\040{\n\040\040\040\040switch\040(op)\040{\n\040\040\040\040\040\040\040\040case\040Expr::BinOp::Op::Add:\040{\n\040\040\040\040\040\040\040\040\040\040\040\040os\040<<\040\"+\";\n\040\040\040\040\040\040\040\040\040\040\040\040break;\n\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040case\040Expr::BinOp::Op::Sub:\040{\n\040\040\040\040\040\040\040\040\040\040\040\040os\040<<\040\"-\";\n\040\040\040\040\040\040\040\040\040\040\040\040break;\n\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040case\040Expr::BinOp::Op::Mul:\040{\n\040\040\040\040\040\040\040\040\040\040\040\040os\040<<\040\"*\";\n\040\040\040\040\040\040\040\040\040\040\040\040break;\n\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040case\040Expr::BinOp::Op::Div:\040{\n\040\040\040\040\040\040\040\040\040\040\040\040os\040<<\040\"/\";\n\040\040\040\040\040\040\040\040\040\040\040\040break;\n\040\040\040\040\040\040\040\040}\n\040\040\040\040\040\040\040\040default:\040{\n\040\040\040\040\040\040\040\040\040\040\040\040AX();\n\040\040\040\040\040\040\040\040}\n\040\040\040\040}\n}\n", -1, true);
    ok = ok && L->test_example(Some<string>("Expr"), "x().y().z(a,\040b,\040c)", -1, true);
    ok = ok && L->test_example(Some<string>("Stmt"), "for\040(Int\040i\040=\0400;\040i\040_LT_\040n;\040i++)\040{\n\040\040\040\040y[i]\040=\040x[i];\n}", -1, true);
    ok = ok && L->test_example(Some<string>("Expr"), "x->m_->at(i)->length()", -1, true);
    ok = ok && L->test_example(Some<string>("Stmt"), "for\040(i1\040=\0400;\040i1\040_LT_\040x->m_->at(i)->length();\040i1++)\040{\n\040\040\040\040expr_data::Node::Expr_T\040y\040=\040xform(x->m_->at(i)->at(i1),\040f);\n\040\040\040\040ret1->push_back(y);\n}", -1, true);
    return !ok;
}
